<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[杂记1]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%9D%82%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[还有一天就回家了，内心不知道是什么感觉，无法描述的那种，工作这半年，没有挣到什么钱，往家里寄了两千，给爸妈和女友换了手机。离理想的生活还差很多很多，多到只能一步步来，工作也要尽快进入正轨，相信年后回来会好很多吧，所以在即将到来的本命年，许个愿。找个至少一万五的工作，尽我所能工作学习。幸福生活是为了自己，可谁都不是只是为了自己活着的。过完这个年，需要面对的就更多了，工作上不再只是一个刚进部门的萌新，需要接起一部分工作。这样才能更快的学到东西，才有资格去要更高的薪资。 明年要开始多挣点钱了，不能像现在这样没有节制的，要有规划，适当的攒点钱，这样在遇到什么急事的时候才能更轻松一点，要把身体锻炼的好一点，要是我垮了，爸妈怎么办，一切都会好起来的。至少开始有能力买自己想买的东西了，可以给自己亲人带来更好的生活，而不是一味的索取了。只要努力就还有希望，因为心里很乱，有句说句，所以可能说的很没有条理，不过这都没啥，就是希望自己能挣点气，努点力，加把劲，在2019年里有所成就。老婆，我爱你，现在能给你的承诺就是我会努力加快我俩幸福生活的步伐，你没有找错人，我会给你幸福的。爸妈，你们会有一个让你们引以为傲的儿子的。 新的一年，愿一切顺利，身体安康，新年快乐！]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>新的展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[soap学习]]></title>
    <url>%2F2019%2F01%2F28%2Fsoap%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[soap是一种简单的基于XML的协议，它使应用程序通过HTTP来交换信息。 SOAP 指简易对象访问协议（Simple Object Access Protocol） SOAP 是一种通信协议 SOAP 用于应用程序之间的通信 SOAP 是一种用于发送消息的格式 SOAP 被设计用来通过因特网进行通信 SOAP 独立于平台 SOAP 独立于语言 SOAP 基于 XML SOAP 很简单并可扩展 SOAP 允许您绕过防火墙 SOAP 将被作为 W3C 标准来发展 对于应用程序开发来说，使程序之间进行因特网通信是很重要的。 目前的应用程序通过使用远程过程调用（RPC）在诸如DCOM与CORBA等对象之间进行通信，但是HTTP不是为此设计的。RPC会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。 通过HTTP在应用程序间的通信是更好的方法，因为HTTP得到了所有的因特网浏览器及服务器的支持。SOAP就是被创造出来完成这个任务的。 SOAP提供了一种标准的方法，使得运行在不同操作系统并使用不同的技术和编程语言的应用程序可以互相进行通信。 –未完–]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础学习</tag>
        <tag>soap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于auto firmware debug的记录]]></title>
    <url>%2F2019%2F01%2F21%2F%E5%85%B3%E4%BA%8Eauto-firmware-debug%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[上周主要的工作就是debug auto firmware功能，QA那边报出的bug是不能正常实现auto firmware upgrade功能，观看QA那边的log发现主要是没有办法正常将下载好的image更新，而在复现的时候肯定是不能让功能按照原有条件运行，因为auto firmware正常实现需要大约十小时闲时检测判断，没有办法立刻看到我们相要的结果，于是修改函数体的判断条件，设置一个参数（Genetest）,在nvram中设置这个值为0，当我们想测试时，将这个值设为1，这样，函数体判断条件满足，开始进行auto firmware upgrade。 因为相对来说debug经验不足，再加上对项目代码模块没有那么熟悉，所以前期是最困难的，没有什么好办法，读代码，请教项目经验的人，特别是当遇到函数逻辑本身没有什么太大问题，但我们不知道跑到那个函数体或者判断语句，甚至不知道为什么会跑到这里的时候，就用到了我们实际工作中经常用到的一项技能，加打印，因为我们的log是源自于console里，加的打印可以在console里很直观的看到，甚至运行的顺序都可以间接的体现出来，这对我们理解功能和代码有巨大的帮助。 cprintf(&quot;Gene debug %s(%d):\n&quot;,__FUNCTION__,__LINE__); 这一小句看似简单的代码，对于debug的过程起到了巨大作用，其实对于我们这种做通讯产品的，在debug过程还有个巨大作用的工具，就会说抓包工具，我们主要用的是wireshark软件和tcpdump指令，当设计抓无线包时就要用到tcpdump指令。 也许解决一个bug可能就是加几行代码或者修改一个数值，可是找到问题所在的过程却往往是考验熟练度和天赋经验的时候，希望自己能早点熟悉。]]></content>
      <categories>
        <category>bug</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git相关学习 day 1]]></title>
    <url>%2F2019%2F01%2F15%2FGit%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0-day-1%2F</url>
    <content type="text"><![CDATA[在没有迫切事物需要处理的时候，学习和巩固最基础的知识对以后的工作肯定是有帮助的，哪怕学的是很杂的东西，积少成多，集腋成裘。 公司用的是svn，所以对svn有些了解，而现在主流的是git，女友说过，当初她希望我搭建github博客的初衷也是希望我能熟练掌握git，这样对以后换到新的单位，也能很快熟悉工作环境。于是今天开始，系统的学习一下git的相关知识。 首先就要知道Git和SVN的区别，其实最主要的区别就是分布式和集中式的区别。 Git是分布式的，在本地有镜像，没有网络的时候也可以提交给本地镜像，待到有网络的时候，再push。每个人的电脑都是一个完整的版本库，彼此之间只需要将各自的修改推送给对方就好了。其实按照这套理论Git是不需要中央服务器的，但通常会设置一个这是为了防止一些情况的发生，例如同事生病没来之类的电脑压根没有开机。 SVN是集中式的，无网络不可以提交。必须要联网，如果是内网稳定还好，如果在互联网上网速慢的话，往往会影响工作效率。 下面还找了一些其他版本控制系统的简单介绍，丰富下认知。 版本库又名仓库，英文repository。在版本库里的所有文件都被Git管控起来，每次修改删除添加都会被记录下来，可以追踪历史，也可以还原。 所以建立一个版本库非常简单，首先找一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/gene/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git init 目录名为了避免不必要的麻烦，尽量不要使用中文。 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可。 把一个文件放到Git仓库只需要两步。 第一步，用git add告诉git，把文件添加到仓库： $ git add readme.txt 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ浏览器被2345劫持]]></title>
    <url>%2F2019%2F01%2F12%2FQQ%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A2%AB2345%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[今天打开QQ浏览器，发现不是原本设置的空白页，而是试图打开http://qq3.z8q.cc/ 根据以往的经验，应该是2345，hao123之类的导航网址。打开Chrome后发现首页未被劫持，所以应该只是简单地更改注册表信息。相对于之前搜狗高速导航劫持要简单得多。 在这里分享下我的解决办法，按下win+R————&gt;输入regedit；找到这个值HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main下和HKEY_CURRENT_USER\Software\Policies\Microsoft\Internet Explorer\Main这个下面的StartPage。 今天遇到的情况就是改变了Microsoft\Internet Explorer\Main下的StartPage值。只需要删除值就好。 这次遇到的相对于之前的搜狗高速导航劫持真的是小巫见大巫，针对于那个只是找到了暂时的解决办法，而没有真的去解决。当时发现无论安装什么浏览器，只要是稍微有点名气的。安装后打开都会遇到首页被劫持为搜狗导航的问题。于是就分析可能性，提出了一种猜测，这种不是简单地修改注册表信息，而应该是有一个脚本，里面包含各大浏览器启动.exe名称。当检测到你点击运行了他表单里存在的.exe时，他就会启动脚本命令浏览器打开搜狗导航。是在你运行之初做出的修改，所以主页保护没有办法对其防护。 于是去验证他，我将运行文件名称修改，如将Chrome.exe修改为谷歌.exe，然后点击发送快捷方式至桌面。点击运行，一切正常。问题得以验证，只是暂时因为技术有限没有找到彻底解决的方法，相信以后对相关技术的加深，终究会找到根本解决方式。这种解决方法除了每装一个新的浏览器就要修改一次名称的繁琐外其实还有一个弊端。就是你会发现任务栏的浏览器图标会出现错误，这里也需要手动修改一下。 这里其实也想说一下，这种流氓行为已经触犯法律了，可是国内对这方面的法律还没有有效的处罚力度。让这样恶意流氓行为可以逍遥法外，相信随着公民对法律和人权意识的重视程度逐渐加深，这种行为终究会不复存在。]]></content>
      <categories>
        <category>破</category>
      </categories>
      <tags>
        <tag>劫持</tag>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp搭建]]></title>
    <url>%2F2019%2F01%2F10%2Fftp%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[解决问题往往需要先复现再从中找到问题所在，在复现的同时搜集数据帮助分析问题，这是很关键的一步。有的时候为了印证自己的猜想，在代码中加入打印，去寻求解决问题的方法。有些bug的复现需要特殊的环境。很多时候需要去QA寻求帮助，借用他们的环境，这样就很不方便，延长了解决问题的时间。如果RD这里自己搭建好环境，久可以加快问题的解决。 在第一天，借用QA的光盘搭建了Ubuntu和win7的双系统，为了方便以后的不时之需，没有用Ubuntu覆盖Windows。这里使用的是Ubuntu１４，没有升级到最新的版本。计划安装ftp https dhcp. 先搭建的是FTP，搭建的过程发现在没有外网的环境下系统内是没有软件包的，后来将主机抱到实验室的外网环境下，将软件包下载完成后，按照设置要求搭建好，中途遇见权限问题，打开conf文件编写后想将其保存后，一直提醒 没有备份，确定保存改变吗 的询问，即使点是。此时依旧会继续弹出提醒，是个死循环。解决的办法就是在控制台里，用权限打开sudo gedit /etc 之类，在编辑后，你点击图形界面的保存就ok了。如果只是单纯的点击图形界面会有一些问题。以及安装好后的530login问题，我找到的原因是因为Ubuntu启用PAM，在用到vsftp时需要用到/etc/pam.d/vsftpd这个文件（源码默认不安装），因此在我关闭匿名登录权限的时候，所有用户都登陆不了。这里删除就好。sudo apt-get remove vsftpd sudo rm /etc/pam.d/vsftpd sudo apt-get install vsftpd]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>服务器</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器模式]]></title>
    <url>%2F2019%2F01%2F08%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1：Access Point（纯AP模式） 纯AP接入点模式，支持802.11b 11MBps或802.11b+ 22MBps的无线网卡接入 2：Wireless Client（网桥模式 ） 跟任何AP桥接的网桥模式。用Site Survey（信号搜索）把对方AP或无线路由的SSID搜索出来，然后点击Connect连接上去，就是这么简单！(工作在这个模式DWL-900AP+就不会再发射信号出来了，只会接收其他AP或无线路由的无线信号然后把无线信号转成有线信号，就象是一个用LAN口无需驱动的无线网卡一样)(无线网桥模式，适用卫星共享，XBOX PS2接入无线网络或当免驱动无线网卡给台式机使用） 3:Wireless Bridge（AP到AP无线桥接 ） 支持两个AP进行无线桥接模式来连通两个不同的局域网，设置桥接模式只要将对方AP的MAC码填进自己AP的“Wireless Bridge”项就可以了，这个模式不会再发射无线信号给其他的无线客户接收。（适合两栋建筑物之间无线通讯使用） 4：Multi-point Bridge（多AP桥接） 支持两个以上的AP进行无线桥接，将放在中心位置的AP选 “Multiple Bridge”（多AP桥接）然后其他AP统一将中心位置的AP的MAC码填进自己的“Wireless Bridge”项就可以。（适合多栋建筑物之间无线通讯使用） 5:Repeater(万能无线信号中继) 支持两台AP之间无线信号中继增强无线距离，或中继其他牌子的无线路由或AP，无论11M 22M 54M 108M都可以中继，已经测试过很多牌子的无线路由和AP，没有发现不兼容的。只要将AP置成Repeater(无线信号中继)、然后用Wireless Client项的Site Survey（信号搜索）搜索附近的AP或其他无线路由的SSID连接上去，然后把对方AP或无线路由的MAC复制到这台AP的Repeater Remote AP MAC栏就可以。只要其他AP或无线路由接上宽带，它就可以接收无线信号再把减弱了的无线信号再放大发送出去，适合距离比较远的无线客户端作信号放大使用，或用来做无线桥接然后再发射信号给无线网卡接收。 (注意！中继其他无线AP或路由时双方的Performance(无线效能值)里面的选项请都填写一样，其中的Preamble Type（前导帧模式）请选Long Preamble（长前导帧），TX Rates选 1-2-5.5-11(Mbps)兼容性会好点)]]></content>
      <categories>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpdump]]></title>
    <url>%2F2019%2F01%2F05%2Ftest2%2F</url>
    <content type="text"><![CDATA[关于tcpdump的一些应用：日常应用tcpdump -D看可以监听的端口tcpdump -i br-lan -w 名字.captftp -p -r 名字.cap 主机ip地址(连接DUT获取的ip)（提取.cap）tftp -g -r 名字.cap 主机ip地址往DUT里放文件 tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -w file ] [ expression ] 抓包选项：-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定”-c 10”将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)， ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用’any’关键字表示所有网络接口。-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-N：不打印出host的域名部分。例如tcpdump将会打印’nic’而不是’nic.ddn.mil’。-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断， ：输出行中会出现”[|proto]”的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量， ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。 输出选项：-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：当分析和打印的时候，产生详细的输出。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。 其他功能性选项：-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于”-i”后。-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。-w：将抓包数据输出到文件中而不是标准输出。可以同时配合”-G time”选项使得输出文件每time秒就自动切换到另一个文件。可通过”-r”选项载入这些文件以进行分析和打印。-r：从给定的数据包文件中读取数据。使用”-“表示从标准输入中读取。]]></content>
      <categories>
        <category>test2</category>
      </categories>
      <tags>
        <tag>test2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F01%2F05%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpdump]]></title>
    <url>%2F2019%2F01%2F05%2Ftcpdump%2F</url>
    <content type="text"><![CDATA[#tcpdumptitle: tcpdumpdate: 2019-01-05 08:41:05 tags: 抓包测试关于tcpdump的一些应用：日常应用tcpdump -D看可以监听的端口tcpdump -i br-lan -w 名字.captftp -p -r 名字.cap 主机ip地址(连接DUT获取的ip)（提取.cap）tftp -g -r 名字.cap 主机ip地址往DUT里放文件 tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -w file ] [ expression ] 抓包选项：-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定”-c 10”将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)， ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用’any’关键字表示所有网络接口。-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-N：不打印出host的域名部分。例如tcpdump将会打印’nic’而不是’nic.ddn.mil’。-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断， ：输出行中会出现”[|proto]”的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量， ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。 输出选项：-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：当分析和打印的时候，产生详细的输出。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。 其他功能性选项：-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于”-i”后。-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。-w：将抓包数据输出到文件中而不是标准输出。可以同时配合”-G time”选项使得输出文件每time秒就自动切换到另一个文件。可通过”-r”选项载入这些文件以进行分析和打印。-r：从给定的数据包文件中读取数据。使用”-“表示从标准输入中读取。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sorry]]></title>
    <url>%2F2019%2F01%2F05%2Fsorry%E5%AF%B9%E4%B8%8D%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[#sorrydate: 2019-01-05 08:05:06 tags: test2不知道说什么好，但是又得写些东西。() function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun(); () 这是引用的内容 这是引用的内容 这是引用的内容 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
