<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[物联网学习]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%89%A9%E8%81%94%E7%BD%91%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这几天除了c语言的温故知新，还在学习有关物联网方面的知识，想着由浅入深，工作是路由器和中继器的开发，在平时的工作中渐渐体会到通讯最后的趋势是万物连接。生活工作以及社会的方方面面之间都会产生联系。而沟通连接所必须的就是各种通信协议，除了当初计算机网络学到的那些osi体系中最基本的通信协议，有关物联网方面还有一些新的协议，以前没有接触过，现在想学习一下，一是拓宽眼界，不能只满足于工作的需求，二是相对来说，单纯路由器中继器相关的工作比较难找，为了未来，我觉得从事物联网方面可能是个不错的选择。智连将改变世界，每个人都将是一个终端。 先前有初步理解MQTT协议，还有一些协议以及他们的特色是适合使用的场景都将在接下的几天进行系统的学习。下面列出一些其他协议之间的一些区别，帮助快速导入。 CoAP和MQTT .MQTT协议使用发布/订阅模型，CoAP协议使用请求/响应模型； .MQTT是长连接，CoAP协议是无连接。MQTT Clients与Broker之间保持TCP长连接，这种情形在NAT环境中也不会产生问题。如果在NAT环境下使用CoAP的话，那就需要采取一些NAT穿透性手段。； .MQTT通过中间代理传递消息的多对多协议，它主要通过让客户端发布消息、代理决定消息路由和复制来解耦消费者和生产者。CoAP协议是Server和Client之间消息传递的单对单协议,MQTT就是相当于消息传递的实时通讯总线； .MQTT不支持带有类型或者其它帮助Clients理解的标签消息，CoAP内置内容协商和发现支持，允许设备彼此窥测以找到交换数据的方式。 .MQTT协议是基于TCP，而CoAP协议是基于UDP。 HTTP和CoAP ．HTTP代表超文本传输协议，CoAP代表约束应用协议； ．HTTP协议的传输层采用了TCP，CoAP协议的传输层使用UDP； ．CoAP协议是HTTP协议的简化版； ．CoAP协议和HTTP协议一样使用请求/响应模型，拥有相同的方法； ．CoAP开销更低，并支持多播； ．CoAP专为资源构成应用而设计，如：IoT/WSN/M2M等… ．CoAP是6LowPAN协议栈中的应用层协议，基于REST（表述性状态传递）架构风格，支持与REST进行交互。通常用户可以像使用HTTP协议一样用CoAP协议来访问物联网设备。而且CoAP消息格式使用简单的二进制格式，最小为4个字节。HTTP使用报文格式对于嵌入式设备来说需要传输数据太多，太重，不够灵活。（ps：6LoWPAN是一种基于IPv6的低速无线个域网标准，即IPv6 over IEEE 802.15.4在查阅之前对这个没有什么印象，可是发现与他相似的有我们学习过的ZigBee协议栈。可是6LoWPAN很有吸引力，因为它基于互联网协议的IP标准工作） 同时找到之前几篇文章图片添加后不显示的原因，因为Markdownpad里面自带的添加图片所使用的图床貌似不可以正常使用了，原因未知，不知是否被墙了或者其他原因。现在更换了图床，已经可以了。]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT]]></title>
    <url>%2F2019%2F03%2F26%2FMQTT%2F</url>
    <content type="text"><![CDATA[写在前面 后面是引用网上的一些定义知识，用于校正理解。刚开始不太清楚MQTT，后来看了别人许多的事例才有一些体会。其实本质就是一个中转服务器，用户自己定义发送数据的标识符和接受数据的标识符，MQTT服务器帮助你接受所有含有你接受标识符的数据，同时将你发送的数据传递到接受数据中标识符的个体。可能此时MQTT服务器心中的OS是：你们把你们想要的标识符告诉我，我替你们转发。可我不管存，只管转。 比方说如果安装了这个服务器,可以设置这个服务器的ip地址和端口号,然后wifi设备(网络设备) 和手机都去连接这个服务器. 下面举个小例子： 对于怎么让wifi设备(网络设备) 的数据发给手机呢。人家规定了,发送数据的时候数据头上先加一些标识(假设是”zou”),手机那边呢设置接收标识为”zou”的数据。 感觉就是加了协议而已,只不过,协议自己可以规定,而且可以设置接收多个标识的数据。 最近没有办法添加图片，待解决。本来画了几幅小图帮助理解。 一、简述 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 二、设计规范 由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则： （1）精简，不添加可有可无的功能； （2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递； （3）允许用户动态创建主题，零运维成本； （4）把传输量降到最低以提高传输效率； （5）把低带宽、高延迟、不稳定的网络等因素考虑在内； （6）支持连续的会话控制； （7）理解客户端计算能力可能很低； （8）提供服务质量管理； （9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。 三、主要特性 MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： （1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。 （2）对负载内容屏蔽的消息传输。 （3）使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 （4）有三种消息发布服务质量：”至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。”至少一次”，确保消息到达，但消息重复可能会发生。”只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。 （5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。 （6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。 Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。 Testament：遗嘱机制，功能类似于Last Will。 四、MQTT协议原理4.1 MQTT协议实现方式 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分： （1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）； （2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 4.2 网络传输与应用消息 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： （1）发布其他客户端可能会订阅的信息； （2）订阅其它客户端发布的消息； （3）退订或删除应用程序的消息； （4）断开与服务器连接。 4.3 MQTT客户端 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： （1）发布其他客户端可能会订阅的信息； （2）订阅其它客户端发布的消息； （3）退订或删除应用程序的消息； （4）断开与服务器连接。 4.4 MQTT服务器 MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以： （1）接受来自客户的网络连接； （2）接受客户发布的应用信息； （3）处理来自客户端的订阅和退订请求； （4）向订阅的客户转发应用程序消息。 4.5 MQTT协议中的订阅、主题、会话一、订阅（Subscription） 订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。二、会话（Session） 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。三、主题名（Topic Name） 连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。四、主题筛选器（Topic Filter） 一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。五、负载（Payload） 消息订阅者所具体接收的内容。 4.6 MQTT协议中的方法 MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有： （1）Connect。等待与服务器建立连接。 （2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。 （3）Subscribe。等待完成订阅。 （4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。 （5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。 五、MQTT协议数据包结构 在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下： （1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。 （2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。 （3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。 5.1 MQTT固定头固定头存在于所有MQTT数据包中，其结构如下：5.1.1 MQTT数据包类型位置：Byte 1中bits 7-4。 相于一个4位的无符号值，类型、取值及描述如下：5.1.2 标识位位置：Byte 1中bits 3-0。 在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接： （1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。 （2）QoS：发布消息的服务质量，即：保证消息传递的次数 Ø00：最多一次，即：&lt;=1 Ø01：至少一次，即：&gt;=1 Ø10：一次，即：=1 Ø11：预留（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length）地址：Byte 2。 固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0 5.2 MQTT可变头 MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识： 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。 5.3 Payload消息体 Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息： （1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。 （2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。 （3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。 （4）UNSUBSCRIBE，消息体内容是要订阅的主题。]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础巩固(二)]]></title>
    <url>%2F2019%2F03%2F22%2Fc-%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[C++的标准输入输出 .包含头文件#include .cout是标准输入输出变量（对象），代表控制台窗口 .&lt;&lt;是一个运算符，假如o是一个输出流对象。x是一个数据 o&lt;&lt;x .cout是标准名字空间std的一个名字。必须加上名字空间限定std::（之所以需要加上名字空间是因为可能会有多个库都有例如print之类的存在，如果不指定，不知调用哪个，防止名字冲突的可能） 可是如果每个都写的话可能有点麻烦，这里有两种解决办法： 1.使用using std::cout 2.也可以引用整个名字空间： using namespace std； C++多态机制的实现 (1)重载：同一个类中同一个函数的不同实现，必须保证函数参数不同（类型，个数，顺序），本质上与多态无关。使用重载函数，编译器会根据函数的名称和参数定义来生成函数的内部标识符，保证每个函数的标识符是唯一的，这样在链接时就可以链接到对应的函数。重载属于静态绑定，在编译过程中就能确定调用哪一个函数，是早期绑定，与多态原理不同。 (2)覆盖：也称为重写，子类中对父类的同名函数同参数的重写，父类的函数必须设置为虚函数，这样保证使用基类指针或者引用指向不同的子类对象可以动态调用属于具体子类的方法而不是调用基类的方法，从而实现多态。 PS:C++中 多态一般默认是指动态多态（通过类继承机制和虚函数机制实现），是在运行时确定的，在面向对象编程中直接被称为多态，而静态多态一般是指使用函数重载或者模板机制实现的。模板也允许将不同的特殊行为和单个泛化记号相关联，由于这种关联处理于编译期而非运行期，因此被称为“静态”。可以用来实现类型安全、运行高效的同质对象集合操作。C++ 的STL库大量使用了模板机制来实现，而并没有使用虚函数机制，属于静态多态。 队列和栈的共同点以及不同点 队列：这里只说单向队列，就是我们平常所说的FIFO队列，它满足先进先出的规则，即只能在队尾插入元素，提取元素只能在队头。（C++里面提供了queue容器作为单向队列的实现） 栈：栈满足LIFO规则（后进先出），插入和取出操作只能在栈顶进行（C++提供了stack容器作为栈的实现） 相同点：都是线性表结构，并且只能在端点进行数据的插入和读取（受限制的线性表结构），都不能进行随机存取，都不支持遍历（不开临时空间），在C++ stl中可以采用deque作为两者的底层容器； 不同点：栈和队列的操作不同，栈只能在线性表的一端进行插入和删除，而队列则是只能在表的一端进行插入，在另一端进行删除；栈符合LIFO原则，而队列符合FIFO原则，即满足队列的操作原则； C++内存模型 一般来说，一个C++程序所分配的内存空间主要分为五个部分：堆、栈、静态存储区、代码段 根据C++中类的情况，可以分为以下几种情况： 单一类： (1)空类：占据一个字节，用于标识这个类是一个空类，没有实际含义，使用sizeof操作符可以看到大小为1个字节。 (2)只有成员变量的类：该类的大小为所有普通成员变量所占据的内存大小的和（静态成员变量并不存放在对象的内存空间中），内存布局如下图所示，可以看出在内存中是按照变量声明的顺序存放的。 (3)只有虚函数的类：根据虚函数的实现机制，该类的对象所占据的内存只有一个虚函数表指针（vfptr)，指向一个虚函数表，该表按照函数的声明顺序存储着虚函数的函数指针。内存布局如下所示： (4)既有虚函数，又有成员变量的类：这样的类的对象内存中既有虚函数表指针，又有成员变量（按照声明的顺序存放），内存布局如下图所示： C++ inline原理 inline是C++的一种机制，作用于函数，将一个函数声明为inline，可以让编译器在编译代码时，将“对此函数的每一个调用”都以函数本体替换之，该过程发生在编译期间。inline的优点是：它可以省去函数调用所带来的额外开销，提高程序的速度。缺点也很明显：首先，过分使用inline函数会导致代码膨胀，占用过多内存和硬盘空间；其次，在升级inline函数时，需要所有引用它的模块都要重新编译。 综合以上说明，inline一般用于函数体比较小，频繁切换的函数上面。另外需要强调的一点是，千万不要将构造或析构函数inline。原因是，这种函数往往看起来是空的，而实际上在编译期间会生成很多代码，如果将它们inline了，很容易就会导致代码膨胀。 define和const的区别 const是定义了一种数据类型，被其修饰的变量会被系统分配内存空间，存放在静态存储区，在编译时会进行类型检查，而define定义的常量本质上是一种宏替换，不是一种数据类型，系统不会为其分配内存空间，宏定义的常量在预处理的时候会被替换，不会进行类型检查。 虚继承和虚基类表、虚基类表指针 虚继承是为了解决多重继承中派生类对象内存同时存在多份虚基类的实体而提出的，当使用虚继承时，派生类中最多保存一份虚基类的实体，但是需要在内存中增加虚基类表指针。 虚继承和虚函数是完全无相关的两个概念。虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。 虚继承可以解决多种继承前面提到的两个问题：虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr指的是虚基类表指针，该指针指向了一个虚基类表，虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 在这里我们可以对比虚函数的实现原理：他们有相似之处，都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）。 虚基类依旧存在继承类中，只占用存储空间；虚函数不占用存储空间。 虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。 ——————————未完——————————]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础学习</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GFW长城防火墙]]></title>
    <url>%2F2019%2F03%2F16%2FGFW%E9%95%BF%E5%9F%8E%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[GFW，即Great Wall of China, 中国防火长城的简称，是中国政府过滤和监控互联网的一套软硬件系统。GFW的作用主要是用于分析和过滤中国境内外网络间的互相访问。也就是说，他不仅能限制国内网民访问境外的某些站点，也能限制国外用户访问国内的站点。 我们通常说的“被墙”，就是指访问被GFW所限制。而”翻墙“，顾名思义，则是突破GFW的限制。这里记录一下GFW的工作原理。 普遍的看法是，GFW 的工作机制主要包括 IP 黑名单、内容审查和 DNS 劫持等三种。 方式一、IP黑名单 GFW可能维护着一张IP黑名单，这里用“可能”二字说明这个说法没有得到过100%的证实，只是通过实验结果推测出来的。事实上，我们无从得知GFW具体的工作原理，这应该属于机密。 下面具体分析下IP黑名单： 37.13.79.144是www.facebook.com众多ip中的一个，但在浏览器中无法访问。 173.252.120.6也是facebook的一个IP,通过这个IP可以访问到其网站。 64.233.189.99是google的一个ip,可以通过浏览器访问谷歌首页，但同属于google 的一个ip 64.233.189.147就不能被访问。由此可以推测 37.13.79.144 和64.233.189.147在GFW的IP黑名单中，只要发现有发往这些ip的请求，就立即终止。 下面来做个实验，208.65.153.238是youtube的一个ip地址，我们在命令行下使用tracert跟踪，如图 在主机202.112.61.214处就断开了。 根据以上结果我们猜测，长城很有可能维护了一张IP黑名单，一旦发现发往黑名单中地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。 进一步，我们有理由认为主机202.112.61.214就是长城的设备之一，为了证实这一猜测，我们用Nmap对其进行了扫描： 扫描结果显示，设备202.112.61.214很有可能是一台Cisco的路由器，这与长城的设备构成是吻合的。 方式二、内容审查 GFW的内容审查针对HTTP传输协议的默认端口的80端口，HTTP传播的内容是明文的内容，没有经过加密，GFW是一个IDS[Intrusion detection system(入侵检测系统)]，GFW有一个敏感字名单，若在中国大陆访问境外的主机的HTTP的数据流里发现敏感字眼，就在两台主机间伪造一个”reset”信号，导致双方主机以为对方中止了请求，通过“合规内容审查”的手段来规避一些非法内容在国内的传播访问。 这种虽然有违互联网open/share的开源分享精神，但是出于国内政治稳定性考虑，做一下审查没有什么不好！ 用Google.com搜索关键词“freegate”，起初我们还能够得到搜索结果， 但是与此同时，我们通过Wireshark抓包可以发现收到了大量“从Google发来的”TCP连接重置包。 刷新页面会发现已经无法访问，并且Google.com也变得无法访问。 我们猜测，长城对HTTP数据包进行了扫描，并且长城内部可能包含有一张敏感词汇列表，一旦发现被扫描数据包中出现敏感词汇，就会立即向源主机和目标主机发送伪装成对方地址的TCP连接重置包，以实现断开连接的目的。 进一步，长城还会在一个临时的黑名单中记录遭到封禁的源主机和目标主机的地址，并保存一段有限长的时间。一旦发现被封禁的源主机在封禁期间再次请求目标主机，将直接返回TCP连接重置包（此时可能是单向的），而无需扫描新的请求数据包。 另一个发现是，这种内容审查机制并非对所有站点起作用，例如，使用Google.cn搜索同样的关键词“freegate”就不会出现被盾的现象。一种可能的原因是，长城启用了一张IP监视名单，而Google.com的地址正是其中之一；另一种可能是，访问Google.cn不会经过***设备，也就不会触发TCP连接重置，而位于长城之外的Google.com则难逃此劫。 方式三、DNS劫持 DSN劫持我想应该是GFW最常用的手段，我们通常都是通过域名访问一个网站，而网络是不识别域名的，必须把域名交给ISP（网络服务提供商）的DNS服务器去解析。比如我们想访问www.facebook.com，这个域名会被发送给你的ISP(例如：中国电信)。它会把你的请求，也就是www.facebook.com，解析到一个虚拟的ip地址，下面我们在命令行下通过nslookup 做个实验就明白了。 上图的结果表明“www.youtube.com”经过DNS服务器166.111.8.28被解析到了地址202.106.1.2，但是事实上，该地址并非Youtube真实地址中的任何一个。进一步，即使使用国外的DNS服务器，如OpenDNS来进行解析，也不能得到Youtube的真实地址： 实际上全球只有13个顶级域名服务器，可惜的是中国一个也没有，为了分流减压，ISP通常都会缓存一些域名信息，而DNS劫持的一个手段就是污染这些缓存信息，也就是修改想要屏蔽的站点的域名信息。 GFW至少使用了两种DNS劫持机制：一方面，GFW对国内DNS服务器进行了缓存污染， 这种污染体现在使用国内DNS服务器对twitter进行解析会得到稳定的、虚假的IP地址；另一 方面，GFW会拦截和应答试图从国内发往国外的DNS解析请求（也可能是对国外DNS服务器 的应答进行了篡改）。 后记 原文作者文中在方式二、内容审查是有图片证实其观点，但本人在实际操作时，发现事实与其所说不符，分析原因可能作者所描述和编写此文章的时候是在2014年之前，因为谷歌搜索是在2014年5月27日被干扰，部分用户出现访问异常，在5月31日被彻底屏蔽。所以现在彻底无法访问所有谷歌产品，除了谷歌翻译（本人目前已知的，也许还有极少几个）。网页作者说其是原创，并在文末有和本文一样的格式化原创声明和转载声明。可是简单的分析，很显然不是如此，文章编辑地址是2018年7月18日，而除了上述的分析，还有其论点： 这个地址也不能访问，所以在为找到原作者的情况下，固不将这篇文章链接公示，望真的原文作者看到后联系删除。]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>GFW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础巩固]]></title>
    <url>%2F2019%2F03%2F12%2Fc-%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[基础很重要，每天巩固，强化知识。 C++兼容C，支持面向对象的方法。 面向对象的程序设计（OOP）方法:将数据及对数据的操作方法封装在一起，作为一个相互依存，不可分离的整体——对象。对同类型对象抽象出其共性形成类。 类中的大多数数据，只能用本类的方法进行处理，类通过一个简单的外部接口，与外界发生关系。对象与对象之间通过消息进行通信。 程序模块间的关系简单，独立性，数据安全性。通过继承与多态性，使程序具有很高的可重用性。 封装：面向对象方法的一个重要原则。 就是把对象的属性和服务结合成一个独立的系统单位，并尽可能的隐蔽对象的内部细节。 含义一：把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位。 含义二：“信息隐蔽”，即尽可能隐蔽对象的内部细节，对外界形成一个边界，只保留有限的对外接口使之与外部发生联系。 继承：特殊类的对象拥有一般类的全部属性与服务，称作特殊类对一般类的继承。 多态性：一般类中定义的属性和行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。 软件开发： 面向对象的分析：OOA 面向对象的设计：OOD 面向对象的编程：OOP 面向对象的测试：OOT 面向对象的软件维护：OOSM ————————未完—————————]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础学习</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VoLTE]]></title>
    <url>%2F2019%2F02%2F25%2FVoLTE%2F</url>
    <content type="text"><![CDATA[VoLTE，一个老生常谈的话题了；之所以能被称之为“老生常谈”，这要得益于中国移动近四五年来坚定不移的大力推广，使得这一给4G插上翅膀飞得更高的技术成为了中国移动的标配，而且，这一功能现在已经成为了中国移动LTE的基础功能。换句话说，这项功能对消费者而言是免费的。 VoLTE与WCDMA 简单科普一下VoLTE与CSFB。 语音传输的本质实际上有两种形式：电路交换（CS，Circuited Switched）和分组交换（PS，Packet Switched）。 CS是指通话前需在网络中建立一条线路，这是“独占”的资源，直到通话结束才拆除。PS是将数据打包传输，这就像快递打包一样，当你的物件被放进快递包后，快递员就不能拆包，必须完好无损的将包裹送到收件者手里，由收件者拆开，无需“独占”资源。 4G时代，所有的资源都是通过数据来进行的，也就是说，要想打电话，只有两个方法，一个就是继续使用GSM的CS技术（没有开通VoLTE功能的移动卡），要么就是将语音数据以封包（Data Packet）的形式在IP网络上传输，这时候就用到了VoIP技术，因为VoIP是采用PS进行传输的，刚好与4G的资源传输模式一样，至此，VoLTE的概念就诞生了。 VoLTE为用户带来更低的接入时延（拨号后的等待时间），比3G降50%，大概在2秒左右，而2G时代在7~8秒。此外，2G、3G下，掉线时有发生，但VoLTE的掉线率接近于零。 这个也就是为什么中国移动要大力推广VOLTE的原因了。那么作为承载中国联通语音业务及半个数据业务的WCDMA又是个什么“东西”呢？ W-CDMA标准主要起源于欧洲和日本的早期第三代无线研究活动，该系统是在现有的GSM网络上进行使用，对于系统提供商而言可以较轻易地过渡，该标准的主要支持者有欧洲、日本、韩国。 中国联通采用WCDMA作为其第三代数字通信标准（3G）。WCDMA是一种3G蜂窝网络，其使用的部分协议与GSM标准一致。从这一点来看，中国联通与国际接轨，使用WCDMA，节省了技术成本及建设成本，这也是直到现在，中国联通的WCDMA都一直坚挺的原因。 TD-SCDMA是ITU（国际电信联盟）批准的多个3G移动通信标准中的一个，也是中国移动使用的第三代通信技术。相对于另两个主要3G标准（WCDMA和CDMA2000），它的起步较晚而且产业链薄弱（2008年中国大陆发放3G牌照，TD-SCDMA在中国只有中国移动使用）。 首先在频谱利用率、频率灵活性、对业务支持具有多样性及成本等方面，TD-SCDMA有独特优势。TD-SCDMA由于采用时分双工，上行和下行信道特性基本一致，因此，基站根据接收信号估计上行和下行信道特性比较容易。此外，TD-SCDMA使用智能天线技术有先天的优势，而智能天线技术的使用又引入了SCDMA的优点，可以减少用户间干扰，从而提高频谱利用率。 但是，由于时分双工体制自身的缺点，TD-SCDMA被认为在终端允许移动速度和小区覆盖半径等方面落后于频分双工体制。同时由于其相对其他3G系统的窄带宽，导致出现扰码短，并且扰码少，在网络侧基本通过扰码来识别小区成为了理论可能——其他两家的已成为了现实。TD-SCDMA只能通过9个频点来做小区的区分，每个载波仅1.6M带宽，导致空口速率远低于WCDMA和CDMA2000。根据实际测试，中国移动部署的TD-SCDMA网在网络速度、稳定性方面较W-CDMA网和CDMA2000网差很多。 简单来说，TD-SCDMA使用的时分双工，就类似于对讲机，不是FULL DUPLEX，也就是不是全双工的，收发不能同时进行，这样效率就非常的低。就像一条马路，要双向行驶，但又不能同时双向行驶，这也是TD-SCDMA技术的一个缺陷。 这个缺陷导致的结果是什么呢？作为消费者最直观的体会就是，下载速率贼慢！ TD-SCDMA在1.6 MHz带宽上理论峰值速率可达到2.8 Mbps（现在版本分为R4/R5/R6/R7，R7的理论值可以达到12M的峰值下载速度。但是现在使用的版本是R4版本），换算一下，实际的使用下载速率就是上述数字除以8，也就是378.2KB/S的下载速度；而中国联通的WCDMA其下载理论峰值速率14.4Mbps，换算一下，1.8MB/S。 这个速度，即便是在5G将要到来的现在，也不至于完全落伍。举个最简单的例子，在玩手游的时候，为什么没有开通VoLTE的中国移动用户在来电时会出现没网的情况呢？其实这不是没网，而是没有VoLTE的支持，中国移动4G呼叫使用语音呼叫技术是CSFB，也就是语音回落技术，电话接通时，手机网络回落至GSM，GSM的网络要求达不到游戏要求，因此会出现游戏断网的现象。 但是联通的WCDMA网络可以满足手游的网络要求，即便是有人打电话过来，开免提继续怼也是没什么问题的。之所以中国联通打电话回落到3G（WCDMA）而中国移动打电话回落至2G（GSM），是因为中国移动的3G（TD-SCDMA）已经已基本完成退网，且TD-SCDMA网络建设存在问题，网络覆盖范围和稳定性都不是很好，因此想退都没得退。]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>VoLTE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F02%2F21%2FMakefile%2F</url>
    <content type="text"><![CDATA[什么是makefile？或许很多Winodws的程序员都不知道，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。 因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。 现在讲述如何写makefile的文章比较多和杂，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，这里所默认的编译器是UNIX下的GCC和CC。 在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。需要指定函数的Object File.1 Makefile 介绍 make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记1]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%9D%82%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>新的展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[soap学习]]></title>
    <url>%2F2019%2F01%2F28%2Fsoap%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[soap是一种简单的基于XML的协议，它使应用程序通过HTTP来交换信息。 SOAP 指简易对象访问协议（Simple Object Access Protocol） SOAP 是一种通信协议 SOAP 用于应用程序之间的通信 SOAP 是一种用于发送消息的格式 SOAP 被设计用来通过因特网进行通信 SOAP 独立于平台 SOAP 独立于语言 SOAP 基于 XML SOAP 很简单并可扩展 SOAP 允许您绕过防火墙 SOAP 将被作为 W3C 标准来发展 对于应用程序开发来说，使程序之间进行因特网通信是很重要的。 目前的应用程序通过使用远程过程调用（RPC）在诸如DCOM与CORBA等对象之间进行通信，但是HTTP不是为此设计的。RPC会产生兼容性以及安全问题；防火墙和代理服务器通常会阻止此类流量。 通过HTTP在应用程序间的通信是更好的方法，因为HTTP得到了所有的因特网浏览器及服务器的支持。SOAP就是被创造出来完成这个任务的。 SOAP提供了一种标准的方法，使得运行在不同操作系统并使用不同的技术和编程语言的应用程序可以互相进行通信。 –未完–]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础学习</tag>
        <tag>soap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于auto firmware debug的记录]]></title>
    <url>%2F2019%2F01%2F21%2F%E5%85%B3%E4%BA%8Eauto-firmware-debug%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[上周主要的工作就是debug auto firmware功能，QA那边报出的bug是不能正常实现auto firmware upgrade功能，观看QA那边的log发现主要是没有办法正常将下载好的image更新，而在复现的时候肯定是不能让功能按照原有条件运行，因为auto firmware正常实现需要大约十小时闲时检测判断，没有办法立刻看到我们相要的结果，于是修改函数体的判断条件，设置一个参数（Genetest）,在nvram中设置这个值为0，当我们想测试时，将这个值设为1，这样，函数体判断条件满足，开始进行auto firmware upgrade。 因为相对来说debug经验不足，再加上对项目代码模块没有那么熟悉，所以前期是最困难的，没有什么好办法，读代码，请教项目经验的人，特别是当遇到函数逻辑本身没有什么太大问题，但我们不知道跑到那个函数体或者判断语句，甚至不知道为什么会跑到这里的时候，就用到了我们实际工作中经常用到的一项技能，加打印，因为我们的log是源自于console里，加的打印可以在console里很直观的看到，甚至运行的顺序都可以间接的体现出来，这对我们理解功能和代码有巨大的帮助。 cprintf(&quot;Gene debug %s(%d):\n&quot;,__FUNCTION__,__LINE__); 这一小句看似简单的代码，对于debug的过程起到了巨大作用，其实对于我们这种做通讯产品的，在debug过程还有个巨大作用的工具，就会说抓包工具，我们主要用的是wireshark软件和tcpdump指令，当设计抓无线包时就要用到tcpdump指令。 也许解决一个bug可能就是加几行代码或者修改一个数值，可是找到问题所在的过程却往往是考验熟练度和天赋经验的时候，希望自己能早点熟悉。]]></content>
      <categories>
        <category>bug</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git相关学习 day 1]]></title>
    <url>%2F2019%2F01%2F15%2FGit%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0-day-1%2F</url>
    <content type="text"><![CDATA[在没有迫切事物需要处理的时候，学习和巩固最基础的知识对以后的工作肯定是有帮助的，哪怕学的是很杂的东西，积少成多，集腋成裘。 公司用的是svn，所以对svn有些了解，而现在主流的是git，女友说过，当初她希望我搭建github博客的初衷也是希望我能熟练掌握git，这样对以后换到新的单位，也能很快熟悉工作环境。于是今天开始，系统的学习一下git的相关知识。 首先就要知道Git和SVN的区别，其实最主要的区别就是分布式和集中式的区别。 Git是分布式的，在本地有镜像，没有网络的时候也可以提交给本地镜像，待到有网络的时候，再push。每个人的电脑都是一个完整的版本库，彼此之间只需要将各自的修改推送给对方就好了。其实按照这套理论Git是不需要中央服务器的，但通常会设置一个这是为了防止一些情况的发生，例如同事生病没来之类的电脑压根没有开机。 SVN是集中式的，无网络不可以提交。必须要联网，如果是内网稳定还好，如果在互联网上网速慢的话，往往会影响工作效率。 下面还找了一些其他版本控制系统的简单介绍，丰富下认知。 版本库又名仓库，英文repository。在版本库里的所有文件都被Git管控起来，每次修改删除添加都会被记录下来，可以追踪历史，也可以还原。 所以建立一个版本库非常简单，首先找一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/gene/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git init 目录名为了避免不必要的麻烦，尽量不要使用中文。 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可。 把一个文件放到Git仓库只需要两步。 第一步，用git add告诉git，把文件添加到仓库： $ git add readme.txt 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ浏览器被2345劫持]]></title>
    <url>%2F2019%2F01%2F12%2FQQ%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A2%AB2345%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[今天打开QQ浏览器，发现不是原本设置的空白页，而是试图打开http://qq3.z8q.cc/ 根据以往的经验，应该是2345，hao123之类的导航网址。打开Chrome后发现首页未被劫持，所以应该只是简单地更改注册表信息。相对于之前搜狗高速导航劫持要简单得多。 在这里分享下我的解决办法，按下win+R————&gt;输入regedit；找到这个值HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main下和HKEY_CURRENT_USER\Software\Policies\Microsoft\Internet Explorer\Main这个下面的StartPage。 今天遇到的情况就是改变了Microsoft\Internet Explorer\Main下的StartPage值。只需要删除值就好。 这次遇到的相对于之前的搜狗高速导航劫持真的是小巫见大巫，针对于那个只是找到了暂时的解决办法，而没有真的去解决。当时发现无论安装什么浏览器，只要是稍微有点名气的。安装后打开都会遇到首页被劫持为搜狗导航的问题。于是就分析可能性，提出了一种猜测，这种不是简单地修改注册表信息，而应该是有一个脚本，里面包含各大浏览器启动.exe名称。当检测到你点击运行了他表单里存在的.exe时，他就会启动脚本命令浏览器打开搜狗导航。是在你运行之初做出的修改，所以主页保护没有办法对其防护。 于是去验证他，我将运行文件名称修改，如将Chrome.exe修改为谷歌.exe，然后点击发送快捷方式至桌面。点击运行，一切正常。问题得以验证，只是暂时因为技术有限没有找到彻底解决的方法，相信以后对相关技术的加深，终究会找到根本解决方式。这种解决方法除了每装一个新的浏览器就要修改一次名称的繁琐外其实还有一个弊端。就是你会发现任务栏的浏览器图标会出现错误，这里也需要手动修改一下。 这里其实也想说一下，这种流氓行为已经触犯法律了，可是国内对这方面的法律还没有有效的处罚力度。让这样恶意流氓行为可以逍遥法外，相信随着公民对法律和人权意识的重视程度逐渐加深，这种行为终究会不复存在。]]></content>
      <categories>
        <category>破</category>
      </categories>
      <tags>
        <tag>劫持</tag>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp搭建]]></title>
    <url>%2F2019%2F01%2F10%2Fftp%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[解决问题往往需要先复现再从中找到问题所在，在复现的同时搜集数据帮助分析问题，这是很关键的一步。有的时候为了印证自己的猜想，在代码中加入打印，去寻求解决问题的方法。有些bug的复现需要特殊的环境。很多时候需要去QA寻求帮助，借用他们的环境，这样就很不方便，延长了解决问题的时间。如果RD这里自己搭建好环境，久可以加快问题的解决。 在第一天，借用QA的光盘搭建了Ubuntu和win7的双系统，为了方便以后的不时之需，没有用Ubuntu覆盖Windows。这里使用的是Ubuntu１４，没有升级到最新的版本。计划安装ftp https dhcp. 先搭建的是FTP，搭建的过程发现在没有外网的环境下系统内是没有软件包的，后来将主机抱到实验室的外网环境下，将软件包下载完成后，按照设置要求搭建好，中途遇见权限问题，打开conf文件编写后想将其保存后，一直提醒 没有备份，确定保存改变吗 的询问，即使点是。此时依旧会继续弹出提醒，是个死循环。解决的办法就是在控制台里，用权限打开sudo gedit /etc 之类，在编辑后，你点击图形界面的保存就ok了。如果只是单纯的点击图形界面会有一些问题。以及安装好后的530login问题，我找到的原因是因为Ubuntu启用PAM，在用到vsftp时需要用到/etc/pam.d/vsftpd这个文件（源码默认不安装），因此在我关闭匿名登录权限的时候，所有用户都登陆不了。这里删除就好。sudo apt-get remove vsftpd sudo rm /etc/pam.d/vsftpd sudo apt-get install vsftpd]]></content>
      <categories>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>服务器</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由器模式]]></title>
    <url>%2F2019%2F01%2F08%2F%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1：Access Point（纯AP模式） 纯AP接入点模式，支持802.11b 11MBps或802.11b+ 22MBps的无线网卡接入 2：Wireless Client（网桥模式 ） 跟任何AP桥接的网桥模式。用Site Survey（信号搜索）把对方AP或无线路由的SSID搜索出来，然后点击Connect连接上去，就是这么简单！(工作在这个模式DWL-900AP+就不会再发射信号出来了，只会接收其他AP或无线路由的无线信号然后把无线信号转成有线信号，就象是一个用LAN口无需驱动的无线网卡一样)(无线网桥模式，适用卫星共享，XBOX PS2接入无线网络或当免驱动无线网卡给台式机使用） 3:Wireless Bridge（AP到AP无线桥接 ） 支持两个AP进行无线桥接模式来连通两个不同的局域网，设置桥接模式只要将对方AP的MAC码填进自己AP的“Wireless Bridge”项就可以了，这个模式不会再发射无线信号给其他的无线客户接收。（适合两栋建筑物之间无线通讯使用） 4：Multi-point Bridge（多AP桥接） 支持两个以上的AP进行无线桥接，将放在中心位置的AP选 “Multiple Bridge”（多AP桥接）然后其他AP统一将中心位置的AP的MAC码填进自己的“Wireless Bridge”项就可以。（适合多栋建筑物之间无线通讯使用） 5:Repeater(万能无线信号中继) 支持两台AP之间无线信号中继增强无线距离，或中继其他牌子的无线路由或AP，无论11M 22M 54M 108M都可以中继，已经测试过很多牌子的无线路由和AP，没有发现不兼容的。只要将AP置成Repeater(无线信号中继)、然后用Wireless Client项的Site Survey（信号搜索）搜索附近的AP或其他无线路由的SSID连接上去，然后把对方AP或无线路由的MAC复制到这台AP的Repeater Remote AP MAC栏就可以。只要其他AP或无线路由接上宽带，它就可以接收无线信号再把减弱了的无线信号再放大发送出去，适合距离比较远的无线客户端作信号放大使用，或用来做无线桥接然后再发射信号给无线网卡接收。 (注意！中继其他无线AP或路由时双方的Performance(无线效能值)里面的选项请都填写一样，其中的Preamble Type（前导帧模式）请选Long Preamble（长前导帧），TX Rates选 1-2-5.5-11(Mbps)兼容性会好点)]]></content>
      <categories>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpdump]]></title>
    <url>%2F2019%2F01%2F05%2Ftest2%2F</url>
    <content type="text"><![CDATA[关于tcpdump的一些应用：日常应用tcpdump -D看可以监听的端口tcpdump -i br-lan -w 名字.captftp -p -r 名字.cap 主机ip地址(连接DUT获取的ip)（提取.cap）tftp -g -r 名字.cap 主机ip地址往DUT里放文件 tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -w file ] [ expression ] 抓包选项：-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定”-c 10”将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)， ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用’any’关键字表示所有网络接口。-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-N：不打印出host的域名部分。例如tcpdump将会打印’nic’而不是’nic.ddn.mil’。-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断， ：输出行中会出现”[|proto]”的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量， ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。 输出选项：-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：当分析和打印的时候，产生详细的输出。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。 其他功能性选项：-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于”-i”后。-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。-w：将抓包数据输出到文件中而不是标准输出。可以同时配合”-G time”选项使得输出文件每time秒就自动切换到另一个文件。可通过”-r”选项载入这些文件以进行分析和打印。-r：从给定的数据包文件中读取数据。使用”-“表示从标准输入中读取。]]></content>
      <categories>
        <category>test2</category>
      </categories>
      <tags>
        <tag>test2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F01%2F05%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpdump]]></title>
    <url>%2F2019%2F01%2F05%2Ftcpdump%2F</url>
    <content type="text"><![CDATA[#tcpdumptitle: tcpdumpdate: 2019-01-05 08:41:05 tags: 抓包测试关于tcpdump的一些应用：日常应用tcpdump -D看可以监听的端口tcpdump -i br-lan -w 名字.captftp -p -r 名字.cap 主机ip地址(连接DUT获取的ip)（提取.cap）tftp -g -r 名字.cap 主机ip地址往DUT里放文件 tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -w file ] [ expression ] 抓包选项：-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定”-c 10”将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)， ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用’any’关键字表示所有网络接口。-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-N：不打印出host的域名部分。例如tcpdump将会打印’nic’而不是’nic.ddn.mil’。-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断， ：输出行中会出现”[|proto]”的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量， ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。 输出选项：-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：当分析和打印的时候，产生详细的输出。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。 其他功能性选项：-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于”-i”后。-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。-w：将抓包数据输出到文件中而不是标准输出。可以同时配合”-G time”选项使得输出文件每time秒就自动切换到另一个文件。可通过”-r”选项载入这些文件以进行分析和打印。-r：从给定的数据包文件中读取数据。使用”-“表示从标准输入中读取。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sorry]]></title>
    <url>%2F2019%2F01%2F05%2Fsorry%E5%AF%B9%E4%B8%8D%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[#sorrydate: 2019-01-05 08:05:06 tags: test2不知道说什么好，但是又得写些东西。() function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun(); () 这是引用的内容 这是引用的内容 这是引用的内容 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
